
---

# **ğŸ“Œ Language Description & Lexical Analysis**

## ğŸ¯ **Learning Objectives**

- **Understand the role** of lexical analyzers in translating PLs.
- **Describe** inputs & outputs of lexical analysis.
- **Apply regular expressions (REs)** to define valid tokens.
- **Map** REs to **Finite State Automata (FSA)** for implementation.
- **Implement a lexical analyzer** and differentiate its errors from later phases.

---

## **ğŸ› ï¸ Compiler Phases**

1. **Lexical Analysis:** Converts **source code â†’ tokens**.
2. **Syntax Analysis:** Builds a **parse tree** from tokens.
3. **Semantic Analysis:** Checks for **semantic errors & type consistency**.
4. **Intermediate Code Generation:** Translates code into an **intermediate representation (IR)**.
5. **Code Optimization:** Improves **performance & efficiency**.
6. **Code Generation:** Converts IR into **machine code**.

ğŸ“ **Analysis Phase:** Steps **1-3** (understanding code).  
ğŸ› ï¸ **Synthesis Phase:** Steps **4-6** (generating executable code).

---

## **ğŸ“Œ Lexical Analysis**

### **ğŸ”¹ What is Lexical Analysis?**

- Breaks source code into **lexemes** (smallest meaningful units).
- Assigns each lexeme a **token** (category name).
- First step in the **compilation process**.

### **ğŸ”¹ Input & Output**

|**Input**|**Lexical Analyzer**|**Output**|
|---|---|---|
|Source Code|Tokenizes lexemes|Tokens|

ğŸ”„ **Example:**

- Input: `int x = 10;`
- Tokens:
    - `int` â†’ **KEYWORD**
    - `x` â†’ **IDENTIFIER**
    - `=` â†’ **ASSIGNMENT OPERATOR**
    - `10` â†’ **INTEGER**
    - `;` â†’ **SEMICOLON**

---

## **ğŸ“Œ Syntax & Grammars**

### **ğŸ”¹ Language & Syntax**

- A **language** is a set of **valid strings** formed using a **set of characters**.
- A **grammar** defines the **rules** for forming **valid sentences/statements**.
- Each **lexeme** belongs to a **token category**.

### **ğŸ”¹ Backus-Naur Form (BNF)**

- **BNF is a metalanguage** that defines programming language syntax.
- **Components:**
    - **Nonterminals**: Abstract symbols (e.g., `<expr>`, `<term>`).
    - **Terminals**: Actual characters in the language (`+`, `*`, `id`).
    - **Production Rules**: Define how symbols expand.

#### **ğŸ”¹ Example BNF Grammar**

```bnf
<expr>  ::= <term> | <expr> + <term> | <expr> - <term>
<term>  ::= <factor> | <term> * <factor>
<factor> ::= <var> | ( <expr> )
<var>   ::= x | y
```

ğŸ’¡ This describes an arithmetic expression grammar.

---

## **ğŸ“Œ Derivations & Parse Trees**

### **ğŸ”¹ What is a Derivation?**

- **A step-by-step process** of applying **grammar rules** to generate valid statements.
- **Leftmost Derivation (LMD):** Always expand **leftmost nonterminal first**.
- **Rightmost Derivation (RMD):** Expand **rightmost nonterminal first**.

#### **ğŸ”¹ Example: Generating `A = B * (A + C)`**

```bnf
<expr> â†’ <term>
<term> â†’ <factor>
<factor> â†’ ( <expr> )
<expr> â†’ <expr> + <term>
<expr> â†’ A + <term>
<term> â†’ C
```

### **ğŸ”¹ Parse Trees**

- A **tree representation** of derivations.
- **Nodes:** Represent tokens & nonterminals.
- **Leaves:** Contain **terminal symbols**.

ğŸ“Œ **Example:** Parse tree for `(x - y) * x + y`

```
         +
        / \
       *   y
      / \
     -   x
    / \
   x   y
```

---

## **ğŸ“Œ Ambiguity in Grammars**

### **ğŸ”¹ What is Ambiguity?**

- A grammar is **ambiguous** if a string has **multiple valid parse trees**.
- Example:

```bnf
<E> â†’ <E> + <E> | <E> * <E> | <N>
```

ğŸ“Œ **For `6 * 17 + 23`, two valid parse trees exist:**

1. `(6 * 17) + 23`
2. `6 * (17 + 23)`

### **ğŸ”¹ Why Avoid Ambiguity?**

- Compilers **derive meaning from parse trees**.
- **If multiple trees exist, behavior is unclear**.

### **ğŸ”¹ Operator Precedence & Associativity**

- **Precedence**: Determines **which operator applies first** (`*` before `+`).
- **Associativity**: Determines **order of evaluation** for same-precedence operators (`left-to-right` or `right-to-left`).

âœ… **Rewrite BNF to enforce precedence:**

```bnf
<expr> ::= <term> | <expr> + <term>
<term> ::= <factor> | <term> * <factor>
<factor> ::= <var> | ( <expr> )
<var> ::= A | B | C
```

Now **`*` takes precedence over `+`**!

---

## **ğŸ“ Exercises**

### **1ï¸âƒ£ Derivation Exercise**

Using **leftmost derivation**, generate:

- `A = (A + B) * C`
- `A = B + C + A`

### **2ï¸âƒ£ Ambiguity Exercise**

Prove that the following grammar is **ambiguous**:

```bnf
<E> â†’ <E> + <E> | <E> * <E> | <N>
<N> â†’ 0 | 1 | 2 | ... 9
```

(Hint: Show **two parse trees** for `6 * 17 + 23`.)

---

## **âœ… Final Thoughts**

- **Lexical Analysis** breaks code into **tokens**.
- **BNF Grammars** define programming syntax.
- **Derivations & Parse Trees** help visualize structure.
- **Avoid ambiguity** for **consistent compiler behavior**.

---
