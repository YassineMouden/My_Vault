
---

# **📌 Language Description & Lexical Analysis**

## 🎯 **Learning Objectives**

- **Understand the role** of lexical analyzers in translating PLs.
- **Describe** inputs & outputs of lexical analysis.
- **Apply regular expressions (REs)** to define valid tokens.
- **Map** REs to **Finite State Automata (FSA)** for implementation.
- **Implement a lexical analyzer** and differentiate its errors from later phases.

---

## **🛠️ Compiler Phases**

1. **Lexical Analysis:** Converts **source code → tokens**.
2. **Syntax Analysis:** Builds a **parse tree** from tokens.
3. **Semantic Analysis:** Checks for **semantic errors & type consistency**.
4. **Intermediate Code Generation:** Translates code into an **intermediate representation (IR)**.
5. **Code Optimization:** Improves **performance & efficiency**.
6. **Code Generation:** Converts IR into **machine code**.

📝 **Analysis Phase:** Steps **1-3** (understanding code).  
🛠️ **Synthesis Phase:** Steps **4-6** (generating executable code).

---

## **📌 Lexical Analysis**

### **🔹 What is Lexical Analysis?**

- Breaks source code into **lexemes** (smallest meaningful units).
- Assigns each lexeme a **token** (category name).
- First step in the **compilation process**.

### **🔹 Input & Output**

|**Input**|**Lexical Analyzer**|**Output**|
|---|---|---|
|Source Code|Tokenizes lexemes|Tokens|

🔄 **Example:**

- Input: `int x = 10;`
- Tokens:
    - `int` → **KEYWORD**
    - `x` → **IDENTIFIER**
    - `=` → **ASSIGNMENT OPERATOR**
    - `10` → **INTEGER**
    - `;` → **SEMICOLON**

---

## **📌 Syntax & Grammars**

### **🔹 Language & Syntax**

- A **language** is a set of **valid strings** formed using a **set of characters**.
- A **grammar** defines the **rules** for forming **valid sentences/statements**.
- Each **lexeme** belongs to a **token category**.

### **🔹 Backus-Naur Form (BNF)**

- **BNF is a metalanguage** that defines programming language syntax.
- **Components:**
    - **Nonterminals**: Abstract symbols (e.g., `<expr>`, `<term>`).
    - **Terminals**: Actual characters in the language (`+`, `*`, `id`).
    - **Production Rules**: Define how symbols expand.

#### **🔹 Example BNF Grammar**

```bnf
<expr>  ::= <term> | <expr> + <term> | <expr> - <term>
<term>  ::= <factor> | <term> * <factor>
<factor> ::= <var> | ( <expr> )
<var>   ::= x | y
```

💡 This describes an arithmetic expression grammar.

---

## **📌 Derivations & Parse Trees**

### **🔹 What is a Derivation?**

- **A step-by-step process** of applying **grammar rules** to generate valid statements.
- **Leftmost Derivation (LMD):** Always expand **leftmost nonterminal first**.
- **Rightmost Derivation (RMD):** Expand **rightmost nonterminal first**.

#### **🔹 Example: Generating `A = B * (A + C)`**

```bnf
<expr> → <term>
<term> → <factor>
<factor> → ( <expr> )
<expr> → <expr> + <term>
<expr> → A + <term>
<term> → C
```

### **🔹 Parse Trees**

- A **tree representation** of derivations.
- **Nodes:** Represent tokens & nonterminals.
- **Leaves:** Contain **terminal symbols**.

📌 **Example:** Parse tree for `(x - y) * x + y`

```
         +
        / \
       *   y
      / \
     -   x
    / \
   x   y
```

---

## **📌 Ambiguity in Grammars**

### **🔹 What is Ambiguity?**

- A grammar is **ambiguous** if a string has **multiple valid parse trees**.
- Example:

```bnf
<E> → <E> + <E> | <E> * <E> | <N>
```

📌 **For `6 * 17 + 23`, two valid parse trees exist:**

1. `(6 * 17) + 23`
2. `6 * (17 + 23)`

### **🔹 Why Avoid Ambiguity?**

- Compilers **derive meaning from parse trees**.
- **If multiple trees exist, behavior is unclear**.

### **🔹 Operator Precedence & Associativity**

- **Precedence**: Determines **which operator applies first** (`*` before `+`).
- **Associativity**: Determines **order of evaluation** for same-precedence operators (`left-to-right` or `right-to-left`).

✅ **Rewrite BNF to enforce precedence:**

```bnf
<expr> ::= <term> | <expr> + <term>
<term> ::= <factor> | <term> * <factor>
<factor> ::= <var> | ( <expr> )
<var> ::= A | B | C
```

Now **`*` takes precedence over `+`**!

---

## **📝 Exercises**

### **1️⃣ Derivation Exercise**

Using **leftmost derivation**, generate:

- `A = (A + B) * C`
- `A = B + C + A`

### **2️⃣ Ambiguity Exercise**

Prove that the following grammar is **ambiguous**:

```bnf
<E> → <E> + <E> | <E> * <E> | <N>
<N> → 0 | 1 | 2 | ... 9
```

(Hint: Show **two parse trees** for `6 * 17 + 23`.)

---

## **✅ Final Thoughts**

- **Lexical Analysis** breaks code into **tokens**.
- **BNF Grammars** define programming syntax.
- **Derivations & Parse Trees** help visualize structure.
- **Avoid ambiguity** for **consistent compiler behavior**.

---
